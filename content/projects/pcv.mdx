---
title: "Interactive 'Higher or Lower' Game with Computer Vision"
date: "2025-01-15"
description: "A Python-based interactive game that replaces traditional keyboard input with real-time playing card detection using OpenCV and Pygame."
tags: ["Computer Vision", "Python", "OpenCV", "Pygame", "IoT"]
---

# Interactive 'Higher or Lower' Game using Computer Vision

## üí° Overview

This project explores the intersection of Human-Computer Interaction (HCI) and game development. Instead of using a mouse or keyboard, players interact with the game using **physical playing cards**. The system uses a camera to "see" the card, identify its rank and suit, and determine the game outcome in real-time[cite: 15, 16].

The core goal was to prove that classic image processing algorithms (like Template Matching) can solve real-world object recognition problems efficiently without needing heavy deep learning models[cite: 37].

<div className="aspect-w-16 aspect-h-9">
  <iframe 
    src="https://www.youtube.com/embed/xwwmVB0pl1c?si=16114TGCpzpv8H3s" 
    frameBorder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
    allowFullScreen>
  </iframe>
</div>
*[Watch the System Demonstration [cite: 155]]*

---

## üõ†Ô∏è Tech Stack

* **Language:** Python
* **Vision Library:** OpenCV (Open Source Computer Vision Library) [cite: 60]
* **Game Engine:** Pygame [cite: 109]
* **Hardware:** Standard Webcam, Laptop

---

## ‚öôÔ∏è How It Works: The Vision Pipeline

The system is split into two main modules: the **Vision Engine** (perception) and the **Game Logic**[cite: 102]. Here is the step-by-step process of how the computer "reads" a card:

### 1. Pre-processing & Edge Detection
Before analyzing the card, the image must be simplified to reduce computational load[cite: 63].
* **Grayscale Conversion:** Converting the image from BGR (Blue-Green-Red) to a single intensity channel.
* **Gaussian Blur:** Smoothing the image to reduce high-frequency noise[cite: 64].
* **Canny Edge Detection:** Extracting the structural lines of the card by detecting drastic changes in pixel intensity (gradients)[cite: 66, 67].


### 2. Perspective Transform (The "Homography" Step)
A major challenge in computer vision is that cards are rarely held perfectly straight. I implemented a **Perspective Transform** to fix this[cite: 71].
* The system detects the four corners of the card contour.
* It calculates a transformation matrix to "warp" the image.
* The result is a flattened, top-down view of the card, regardless of how the user holds it[cite: 72, 75].

### 3. Template Matching (Classification)
Instead of using Neural Networks, I used a lightweight **Template Matching** method with the **Sum of Absolute Differences (SAD)** algorithm[cite: 17, 78].
* The system compares the flattened card image against a database of 52 reference card images.
* The template with the lowest difference score is identified as the match[cite: 79, 80].

---

## üé≤ Game Logic Implementation

The game follows the standard "Higher or Lower" rules implemented in `game_logic.py`[cite: 106].

* **Mapping:** Cards are mapped to numerical values (e.g., Jack = 11, King = 13)[cite: 121].
* **State Management:** The system handles states to prevent crashes, ensuring a card is detected before a guess is registered[cite: 122].

```python
# Snippet: Safety validation before processing a guess [cite: 124-129]
if self.current_card is None:
    self.message = "Wait for Reference Card! Press 'R'."
    return False
if self.next_card is None:
    self.message = "Wait for GUESS Card detection!"
    return False